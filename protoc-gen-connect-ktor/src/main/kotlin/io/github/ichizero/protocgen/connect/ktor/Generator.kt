package io.github.ichizero.protocgen.connect.ktor

import com.connectrpc.*
import com.connectrpc.protocgen.connect.internal.CodeGenerator
import com.connectrpc.protocgen.connect.internal.Plugin
import com.google.protobuf.DescriptorProtos
import com.google.protobuf.Descriptors
import com.google.protobuf.compiler.PluginProtos
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.github.ichizero.protocgen.connect.ktor.internal.*
import io.ktor.http.*
import io.ktor.resources.Resource
import io.ktor.server.application.ApplicationCall
import io.ktor.server.routing.*

class Generator : CodeGenerator {
    override fun generate(
        request: PluginProtos.CodeGeneratorRequest,
        descriptorSource: Plugin.DescriptorSource,
        response: Plugin.Response,
    ) {
        val protoFilesMap = request.protoFileList.associateBy { it.name }

        lateinit var packageName: String
        request.fileToGenerateList.map { fileName ->
            val file = descriptorSource.findFileByName(fileName)
                ?: throw RuntimeException("no descriptor sources found.")
            packageName = getFileJavaPackage(file)

            val protoFile = protoFilesMap[file.name]
                ?: throw RuntimeException("no proto file found.")

            if (file.services.isEmpty()) return@map

            val fileMap = parseFile(file, SourceInfo(protoFile, descriptorSource, emptyList()))

            for ((className, fileSpec) in fileMap) {
                try {
                    response.addFile("${className.canonicalName.packageToDirectory()}.kt", fileSpec.toString())
                } catch (e: Throwable) {
                    throw Throwable("failure on generating ${file.name}", e)
                }
            }
        }

        response.addFile(
            "${packageName.packageToDirectory()}/ConnectKtorUtils.kt",
            connectKtorUtils(packageName).toString(),
        )
    }

    override fun getSupportedFeatures(): Array<PluginProtos.CodeGeneratorResponse.Feature> = arrayOf(
        PluginProtos.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL,
        PluginProtos.CodeGeneratorResponse.Feature.FEATURE_SUPPORTS_EDITIONS,
    )

    override fun getMinimumEdition(): DescriptorProtos.Edition = DescriptorProtos.Edition.EDITION_PROTO2

    override fun getMaximumEdition(): DescriptorProtos.Edition = DescriptorProtos.Edition.EDITION_2023

    private fun connectKtorUtils(packageName: String): FileSpec = FileSpec
        .builder(packageName, "ConnectKtorUtils.kt")
        .addImport(Code::class.java.`package`.name, "Code")
        .addImport(ResponseMessage::class.java.`package`.name, "ResponseMessage")
        .addImport("com.connectrpc", "fold")
        .addImport(HttpStatusCode::class.java.`package`.name, "HttpStatusCode")
        .addImport(ApplicationCall::class.java.`package`.name, "ApplicationCall")
        .addImport("io.ktor.server.response", "respond")
        .addImport(RoutingContext::class.java.`package`.name, "RoutingContext")
        .addFileComment("Code generated by connect-ktor. DO NOT EDIT.\n")
        .addFileComment("\n")
        .addFunction(
            FunSpec
                .builder("asHTTPStatusCode")
                .receiver(Code::class)
                .returns(HttpStatusCode::class)
                .addStatement(
                    """return when (this) {
    Code.CANCELED -> HttpStatusCode(value = 499, description = "Client Closed Request")
    Code.UNKNOWN -> HttpStatusCode.InternalServerError
    Code.INVALID_ARGUMENT -> HttpStatusCode.BadRequest
    Code.DEADLINE_EXCEEDED -> HttpStatusCode.GatewayTimeout
    Code.NOT_FOUND -> HttpStatusCode.NotFound
    Code.ALREADY_EXISTS -> HttpStatusCode.Conflict
    Code.PERMISSION_DENIED -> HttpStatusCode.Forbidden
    Code.RESOURCE_EXHAUSTED -> HttpStatusCode.TooManyRequests
    Code.FAILED_PRECONDITION -> HttpStatusCode.BadRequest
    Code.ABORTED -> HttpStatusCode.Conflict
    Code.OUT_OF_RANGE -> HttpStatusCode.BadRequest
    Code.UNIMPLEMENTED -> HttpStatusCode.NotImplemented
    Code.INTERNAL_ERROR -> HttpStatusCode.InternalServerError
    Code.UNAVAILABLE -> HttpStatusCode.ServiceUnavailable
    Code.DATA_LOSS -> HttpStatusCode.InternalServerError
    Code.UNAUTHENTICATED -> HttpStatusCode.Unauthorized
}""",
                ).build(),
        ).addFunction(
            FunSpec
                .builder("handle")
                .addModifiers(KModifier.INLINE)
                .addTypeVariable(TypeVariableName("Resource", Any::class).copy(reified = true))
                .addTypeVariable(TypeVariableName("Req", Any::class).copy(reified = true))
                .addTypeVariable(TypeVariableName("Res", Any::class).copy(reified = true))
                .addParameter(
                    ParameterSpec
                        .builder(
                            "handlerFunc",
                            LambdaTypeName
                                .get(
                                    parameters = listOf(
                                        ParameterSpec.builder("request", TypeVariableName("Req")).build(),
                                        ParameterSpec.builder("call", ApplicationCall::class).build(),
                                    ),
                                    returnType = ResponseMessage::class.asClassName().parameterizedBy(
                                        TypeVariableName("Res"),
                                    ),
                                ).copy(suspending = true),
                            KModifier.NOINLINE,
                        ).build(),
                ).returns(
                    LambdaTypeName
                        .get(
                            receiver = RoutingContext::class.asTypeName(),
                            parameters = listOf(
                                ParameterSpec.unnamed(TypeVariableName("Resource")),
                                ParameterSpec.unnamed(TypeVariableName("Req")),
                            ),
                            returnType = Unit::class.asTypeName(),
                        ).copy(suspending = true),
                ).addStatement(
                    """return { _, request ->
    handlerFunc(request, call)
        .also { response ->
            response.headers.map { (key, value) -> 
                value.map { call.response.headers.append(key, it) }
            }
            response.trailers.map { (key, value) ->
                value.map { call.response.headers.append("Trailer-${'$'}key", it) }
            }
        }.fold(
            onSuccess = { call.respond(it) },
            onFailure = { call.respond(it.code.asHTTPStatusCode()) },
        )
}
                    """.trimIndent(),
                ).build(),
        ).build()

    private fun parseFile(file: Descriptors.FileDescriptor, baseSourceInfo: SourceInfo): Map<ClassName, FileSpec> {
        val packageName = getFileJavaPackage(file)

        return file.services
            .withSourceInfo(baseSourceInfo, DescriptorProtos.FileDescriptorProto.SERVICE_FIELD_NUMBER)
            .associate { (sourceInfo, service) ->
                serviceHandlerInterfaceClassName(packageName, service) to
                    FileSpec
                        .builder(packageName, file.name)
                        .addImport(ResponseMessage::class.java.`package`.name, "ResponseMessage")
                        .addImport(Resource::class.java.`package`.name, "Resource")
                        .addImport(ApplicationCall::class.java.`package`.name, "ApplicationCall")
                        .addImport("io.ktor.server.resources", "post")
                        .addImport(Route::class.java.`package`.name, "Route")
                        .addFileComment("Code generated by connect-ktor. DO NOT EDIT.\n")
                        .addFileComment("\n")
                        .addFileComment("Source: ${file.name}\n")
                        .suppressDeprecationWarnings(file)
                        .addType(serviceHandlerInterface(packageName, service, file, sourceInfo))
                        .addFunction(serviceRouter(packageName, service))
                        .build()
            }
    }

    private fun serviceHandlerInterface(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
        file: Descriptors.FileDescriptor,
        sourceInfo: SourceInfo,
    ): TypeSpec = TypeSpec
        .interfaceBuilder(serviceHandlerInterfaceClassName(packageName, service))
        .addServiceDeprecation(service, file)
        .addKdoc(sourceInfo.comment().sanitizeKdoc())
        .addType(
            TypeSpec
                .objectBuilder("Procedures")
                .addTypes(
                    service.methods.mapNotNull { method ->
                        if (method.isClientStreaming || method.isServerStreaming) return@mapNotNull null

                        TypeSpec
                            .classBuilder(method.name.upperCamelCase())
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(Resource::class)
                                    .addMember("%S", "/${method.service.fullName}/${method.name}")
                                    .build(),
                            ).build()
                    },
                ).build(),
        ).addFunctions(interfaceMethods(service.methods, sourceInfo))
        .build()

    private fun interfaceMethods(
        methods: List<Descriptors.MethodDescriptor>,
        baseSourceInfo: SourceInfo,
    ): List<FunSpec> = methods
        .withSourceInfo(
            baseSourceInfo,
            DescriptorProtos.ServiceDescriptorProto.METHOD_FIELD_NUMBER,
        ).mapNotNull { (sourceInfo, method) ->
            if (method.isClientStreaming || method.isServerStreaming) return@mapNotNull null

            val inputClassName = classNameFromType(method.inputType)
            val outputClassName = classNameFromType(method.outputType)

            FunSpec.Companion
                .builder(method.name.lowerCamelCase())
                .addKdoc(sourceInfo.comment().sanitizeKdoc())
                .addMethodDeprecation(method)
                .addModifiers(KModifier.SUSPEND)
                .addModifiers(KModifier.ABSTRACT)
                .addParameter("request", inputClassName)
                .addParameter("call", ApplicationCall::class)
                .returns(ResponseMessage::class.asClassName().parameterizedBy(outputClassName))
                .clearBody()
                .build()
        }

    private fun serviceRouter(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
    ): FunSpec {
        val interfaceClassName = serviceHandlerInterfaceClassName(packageName, service)
        return FunSpec
            .builder(service.name.lowerCamelCase())
            .receiver(Route::class)
            .addParameter("handler", serviceHandlerInterfaceClassName(packageName, service))
            .let { fs ->
                service.methods.fold(fs) { acc, method ->
                    if (method.isClientStreaming || method.isServerStreaming) return@fold acc
                    acc.addStatement(
                        "post<%T.Procedures.%T, %T>(handle(handler::%L))",
                        interfaceClassName,
                        ClassName(packageName, method.name.upperCamelCase()),
                        classNameFromType(method.inputType),
                        method.name.lowerCamelCase(),
                    )
                }
            }.build()
    }

    private fun serviceHandlerInterfaceClassName(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
    ): ClassName = ClassName(packageName, "${service.name}Handler")

    private fun classNameFromType(descriptor: Descriptors.Descriptor): ClassName {
        val packageName = getFileJavaPackage(descriptor.file)
        val names = getClassName(descriptor)
            .removePrefix(packageName)
            .removePrefix(".")
            .split(".")
        if (names.size > 1) {
            return ClassName(packageName, names.first(), *names.subList(1, names.size).toTypedArray())
        }
        return ClassName(packageName, names.first())
    }
}
