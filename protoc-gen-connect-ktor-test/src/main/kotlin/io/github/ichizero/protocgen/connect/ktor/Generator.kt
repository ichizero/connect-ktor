package io.github.ichizero.protocgen.connect.ktor

import com.connectrpc.*
import com.connectrpc.protocgen.connect.internal.CodeGenerator
import com.connectrpc.protocgen.connect.internal.Plugin
import com.google.protobuf.DescriptorProtos
import com.google.protobuf.Descriptors
import com.google.protobuf.compiler.PluginProtos
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import io.github.ichizero.protocgen.connect.ktor.internal.*
import io.ktor.http.*
import io.ktor.resources.Resource
import io.ktor.server.application.ApplicationCall
import io.ktor.server.routing.*

class Generator : CodeGenerator {
    override fun generate(
        request: PluginProtos.CodeGeneratorRequest,
        descriptorSource: Plugin.DescriptorSource,
        response: Plugin.Response,
    ) {
        val protoFilesMap = request.protoFileList.associateBy { it.name }

        lateinit var packageName: String
        request.fileToGenerateList.map { fileName ->
            val file = descriptorSource.findFileByName(fileName)
                ?: throw RuntimeException("no descriptor sources found.")
            packageName = getFileJavaPackage(file)

            val protoFile = protoFilesMap[file.name]
                ?: throw RuntimeException("no proto file found.")

            if (file.services.isEmpty()) return@map

            val fileMap = parseFile(file, SourceInfo(protoFile, descriptorSource, emptyList()))

            for ((className, fileSpec) in fileMap) {
                try {
                    response.addFile("${className.canonicalName.packageToDirectory()}.kt", fileSpec.toString())
                } catch (e: Throwable) {
                    throw Throwable("failure on generating ${file.name}", e)
                }
            }
        }
    }

    override fun getSupportedFeatures(): Array<PluginProtos.CodeGeneratorResponse.Feature> = arrayOf(
        PluginProtos.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL,
        PluginProtos.CodeGeneratorResponse.Feature.FEATURE_SUPPORTS_EDITIONS,
    )

    override fun getMinimumEdition(): DescriptorProtos.Edition = DescriptorProtos.Edition.EDITION_PROTO2

    override fun getMaximumEdition(): DescriptorProtos.Edition = DescriptorProtos.Edition.EDITION_2023

    private fun parseFile(file: Descriptors.FileDescriptor, baseSourceInfo: SourceInfo): Map<ClassName, FileSpec> {
        val packageName = getFileJavaPackage(file)

        return file.services
            .withSourceInfo(baseSourceInfo, DescriptorProtos.FileDescriptorProto.SERVICE_FIELD_NUMBER)
            .associate { (sourceInfo, service) ->
                serviceHandlerInterfaceClassName(packageName, service) to
                    FileSpec
                        .builder(packageName, file.name)
                        .addImport(ResponseMessage::class.java.`package`.name, "ResponseMessage")
                        .addImport("io.github.ichizero.connect.ktor", "handle")
                        .addImport(Resource::class.java.`package`.name, "Resource")
                        .addImport(ApplicationCall::class.java.`package`.name, "ApplicationCall")
                        .addImport("io.ktor.server.resources", "post")
                        .addImport(Route::class.java.`package`.name, "Route")
                        .addFileComment("Code generated by connect-ktor. DO NOT EDIT.\n")
                        .addFileComment("\n")
                        .addFileComment("Source: ${file.name}\n")
                        .suppressDeprecationWarnings(file)
                        .addType(serviceHandlerInterface(packageName, service, file, sourceInfo))
                        .addFunction(serviceRouter(packageName, service))
                        .build()
            }
    }

    private fun serviceHandlerInterface(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
        file: Descriptors.FileDescriptor,
        sourceInfo: SourceInfo,
    ): TypeSpec = TypeSpec
        .interfaceBuilder(serviceHandlerInterfaceClassName(packageName, service))
        .addServiceDeprecation(service, file)
        .addKdoc(sourceInfo.comment().sanitizeKdoc())
        .addType(
            TypeSpec
                .objectBuilder("Procedures")
                .addTypes(
                    service.methods.mapNotNull { method ->
                        if (method.isClientStreaming || method.isServerStreaming) return@mapNotNull null

                        TypeSpec
                            .classBuilder(method.name.upperCamelCase())
                            .addAnnotation(
                                AnnotationSpec
                                    .builder(Resource::class)
                                    .addMember("%S", "/${method.service.fullName}/${method.name}")
                                    .build(),
                            ).build()
                    },
                ).build(),
        ).addFunctions(interfaceMethods(service.methods, sourceInfo))
        .build()

    private fun interfaceMethods(
        methods: List<Descriptors.MethodDescriptor>,
        baseSourceInfo: SourceInfo,
    ): List<FunSpec> = methods
        .withSourceInfo(
            baseSourceInfo,
            DescriptorProtos.ServiceDescriptorProto.METHOD_FIELD_NUMBER,
        ).mapNotNull { (sourceInfo, method) ->
            if (method.isClientStreaming || method.isServerStreaming) return@mapNotNull null

            val inputClassName = classNameFromType(method.inputType)
            val outputClassName = classNameFromType(method.outputType)

            FunSpec.Companion
                .builder(method.name.lowerCamelCase())
                .addKdoc(sourceInfo.comment().sanitizeKdoc())
                .addMethodDeprecation(method)
                .addModifiers(KModifier.SUSPEND)
                .addModifiers(KModifier.ABSTRACT)
                .addParameter("request", inputClassName)
                .addParameter("call", ApplicationCall::class)
                .returns(ResponseMessage::class.asClassName().parameterizedBy(outputClassName))
                .clearBody()
                .build()
        }

    private fun serviceRouter(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
    ): FunSpec {
        val interfaceClassName = serviceHandlerInterfaceClassName(packageName, service)
        return FunSpec
            .builder(service.name.lowerCamelCase())
            .receiver(Route::class)
            .addParameter("handler", serviceHandlerInterfaceClassName(packageName, service))
            .let { fs ->
                service.methods.fold(fs) { acc, method ->
                    if (method.isClientStreaming || method.isServerStreaming) return@fold acc
                    acc.addStatement(
                        "post<%T.Procedures.%T, %T>(handle(handler::%L))",
                        interfaceClassName,
                        ClassName(packageName, method.name.upperCamelCase()),
                        classNameFromType(method.inputType),
                        method.name.lowerCamelCase(),
                    )
                }
            }.build()
    }

    private fun serviceHandlerInterfaceClassName(
        packageName: String,
        service: Descriptors.ServiceDescriptor,
    ): ClassName = ClassName(packageName, "${service.name}Handler")

    private fun classNameFromType(descriptor: Descriptors.Descriptor): ClassName {
        val packageName = getFileJavaPackage(descriptor.file)
        val names = getClassName(descriptor)
            .removePrefix(packageName)
            .removePrefix(".")
            .split(".")
        if (names.size > 1) {
            return ClassName(packageName, names.first(), *names.subList(1, names.size).toTypedArray())
        }
        return ClassName(packageName, names.first())
    }
}
